<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <h1>Advanced Types</h1>
    <section>
      <h2>Intersection Types 交差タイプ</h2>
      <p>
        An intersection type combines multiple types into one. This allows you
        to add together existing types to get a single type that has all the
        features you need. For example, Person & Serializable & Loggable is a
        Person and Serializable and Loggable. That means an object of this type
        will have all members of all three types.
      </p>
      <p>
        交差型(intersection type)は複数の型を1つに連結したものです。
        これは既存の型を統合し、必要とする機能を全て備えた1つの型を得ることを可能にしてくれます。
      </p>

      <p>
        You will mostly see intersection types used for mixins and other
        concepts that don’t fit in the classic object-oriented mold. (There are
        a lot of these in JavaScript!) Here’s a simple example that shows how to
        create a mixin:
      </p>
      <p>
        あなたは、ミックスインやその他の古典的なオブジェクト指向に囚われない処理上で、交差型を見かけることになるでしょう。
        (こういったことはJavaScriptには非常に多いです!)
        下記の例は、ミックスインの作り方を示しています。
      </p>
      <pre><code>
        function extend&lt;First, Second&gt;(first: First, second: Second): First & Second {
            const result: Partial&lt;First & Second&gt; = {};
            for (const prop in first) {
                if (first.hasOwnProperty(prop)) {
                    (&lt;First&gt;result)[prop] = first[prop];
                }
            }
            for (const prop in second) {
                if (second.hasOwnProperty(prop)) {
                    (&lt;Second&gt;result)[prop] = second[prop];
                }
            }
            return &lt;First & Second&gt;result;
        }
        
        class Person {
            constructor(public name: string) { }
        }
        
        interface Loggable {
            log(name: string): void;
        }
        
        class ConsoleLogger implements Loggable {
            log(name) {
                console.log(`Hello, I'm ${name}.`);
            }
        }
        
        const jim = extend(new Person('Jim'), ConsoleLogger.prototype);
        jim.log(jim.name);
      </code></pre>
    </section>

    <section>
      <h2>Union Types</h2>
      <p>
        Union types are closely related to intersection types, but they are used
        very differently. Occasionally, you’ll run into a library that expects a
        parameter to be either a number or a string. For instance, take the
        following function:
      </p>
      <p>
        共用体型(Union
        types)は交差型と密接な関係がありますが、これらの使用方法は全く異なります。
        時に、数値または文字列どちらかのパラメーターを期待するライブラリを実行することがあるでしょう。
        例えば、下記の関数があるとします。
      </p>
      <pre><code>/**
                * Takes a string and adds "padding" to the left.
* If 'padding' is a string, then 'padding' is appended to the left side.
* If 'padding' is a number, then that number of spaces is added to the left side.
*/
function padLeft(value: string, padding: any) {
    if (typeof padding === "number") {
        return Array(padding + 1).join(" ") + value;
    }
    if (typeof padding === "string") {
        return padding + value;
    }
    throw new Error(`Expected string or number, got '${padding}'.`);
}

padLeft("Hello world", 4); // returns "    Hello world"
</code></pre>

      <p>
        The problem with padLeft is that its padding parameter is typed as any.
        That means that we can call it with an argument that’s neither a number
        nor a string, but TypeScript will be okay with it.
      </p>
      <p>
        padLeftの問題は、paddingパラメーターの型がanyであることです。
        これは引数に数値でも文字列でも無いものも指定して呼び出すことが可能であることを意味しますが、
        TypeScriptではこれは問題無いとして扱います。
      </p>

      <pre><code>let indentedString = padLeft("Hello world", true); // passes at compile
            time, fails at runtime.
      </code></pre>

      <p>
        In traditional object-oriented code, we might abstract over the two
        types by creating a hierarchy of types. While this is much more
        explicit, it’s also a little bit overkill. One of the nice things about
        the original version of padLeft was that we were able to just pass in
        primitives. That meant that usage was simple and concise. This new
        approach also wouldn’t help if we were just trying to use a function
        that already exists elsewhere.
      </p>
      <p>
        padLeftの元のバージョンの素晴らしいことの1つは、プリミティブ値を渡すだけで良いことです。
        使用することに関して言えば、シンプルで簡潔であると言えるでしょう。
        この新しいアプローチでも、既に他の場所で関数が使用されていた場合には、それを手助けすることはできないでしょう。
      </p>
      <p>
        Instead of any, we can use a union type for the padding parameter:
      </p>
      <p>
        そこでanyの代わりに、paddingパラメーターのために共用体型(union
        type)を使用します。
      </p>
      <pre><code>
        /**
        * Takes a string and adds "padding" to the left.
        * If 'padding' is a string, then 'padding' is appended to the left side.
        * If 'padding' is a number, then that number of spaces is added to the left side.
        */
       function padLeft(value: string, padding: string | number) {
           // ...
       }
       
       let indentedString = padLeft("Hello world", true); // errors during compilation
</code></pre>

      <p>
        A union type describes a value that can be one of several types. We use
        the vertical bar (|) to separate each type, so number | string | boolean
        is the type of a value that can be a number, a string, or a boolean.
      </p>
      <p>
        共用体型(union types)は値が幾つかの型のうちの一つであることを表します。
        各型を縦棒(|)で区切ます。 number | string |
        booleanであれば、その値は数値、文字列、真偽値になることが可能です。
      </p>
      <p>
        If we have a value that has a union type, we can only access members
        that are common to all types in the union.
      </p>
      <p>
        共用体型(union
        types)の値を持つ場合、全ての型で共通するメンバにしか、アクセスすることはできません。
      </p>
      <pre><code>interface Bird {
            fly();
            layEggs();
        }
        interface Fish {
            swim();
            layEggs();
        }
        function getSmallPet(): Fish | Bird {
            // ...
        }
        let pet = getSmallPet();
        pet.layEggs(); // OK
        pet.swim();    // エラー
        </code></pre>
      <p>
        Union types can be a bit tricky here, but it just takes a bit of
        intuition to get used to. If a value has the type A | B, we only know
        for certain that it has members that both A and B have. In this example,
        Bird has a member named fly. We can’t be sure whether a variable typed
        as Bird | Fish has a fly method. If the variable is really a Fish at
        runtime, then calling pet.fly() will fail.
      </p>
      <p>
        ここでの共用体型(union
        types)は少しトリッキーかもしれませんが、慣れるためには少し直感力が必要かもしれません。
        もし値がA |
        Bを持つ場合、そのメンバはAとBの両方で共通するメンバを持つことのみが確定されます。
        この例では、Birdはflyというメンバを持ちますが、 Bird |
        Fishとしての変数の型が、flyメソッドを持つことは確定されません。
        もし、変数がランタイム時にはFishである場合、pet.fly()の呼び出しは失敗します。
      </p>
    </section>

    <section>
      <h2>Type Guards and Differentiating Types 型の保護と型の識別</h2>
      <p>
        Union types are useful for modeling situations when values can overlap
        in the types they can take on. What happens when we need to know
        specifically whether we have a Fish? A common idiom in JavaScript to
        differentiate between two possible values is to check for the presence
        of a member. As we mentioned, you can only access members that are
        guaranteed to be in all the constituents of a union type.
      </p>
      <p>
        共用体型(union
        types)は、値が取り得ることが出来る型を重ね持つ際に、それをモデリングする際に便利です。
        ただし、Fishを持つのかどうかを明確に知る必要がある場合に、どうすればよいのでしょうか？
        値が2つの型のどちらかの可能性がある場合にそれを識別するには、一般的なJavaScriptであれば提供されるメンバを調べます。
        既に述べたようにアクセス可能なメンバは、共用体型(union
        types)の全てで構成要素となっていることが保証されているメンバだけです。
      </p>
      <pre><code>let pet = getSmallPet();

// Each of these property accesses will cause an error
if (pet.swim) {
    pet.swim();
}
else if (pet.fly) {
    pet.fly();
}</code></pre>

      <p>
        To get the same code working, we’ll need to use a type assertion:
      </p>
      <p>
        同じコードを機能させるには、型アサーションを使用する必要があります。
      </p>
      <pre><code>let pet = getSmallPet();

if ((&lt;Fish&gt;pet).swim) {
    (&lt;Fish&gt;pet).swim();
}
else {
    (&lt;Bird&gt;pet).fly();
}</code></pre>

      <section>
        <h3>User-Defined Type Guards</h3>
        <p>
          Notice that we had to use type assertions several times. It would be
          much better if once we performed the check, we could know the type of
          pet within each branch.
        </p>
        <p>
          この場合、あるゆる場所で型注釈(type
          assertion)を使わなければいけません。
          理想を言えば、型のチェックを一度行ったのであれば、その各分岐部分ではpetの型であることが知られるようになることです。
        </p>
        <p>
          It just so happens that TypeScript has something called a type guard.
          A type guard is some expression that performs a runtime check that
          guarantees the type in some scope. To define a type guard, we simply
          need to define a function whose return type is a type predicate:
        </p>
        <p>
          TypeScriptにはこのような仕組みがあり、これは「型の保護(type
          guard)」と呼ばれています。
          型の保護は、あるスコープ内で型が保証されることをチェックする、ランタイム時に実行される式になります。
          型の保護を定義するには、単純に「型述語(type
          predicate)」を返す関数を定義する必要があります。
        </p>
        <pre><code>function isFish(pet: Fish | Bird): pet is Fish {
    return (&lt;Fish&gt;pet).swim !== undefined;
}</code></pre>

        <p>
          <code>pet is Fish</code> is our type predicate in this example. A
          predicate takes the form <code>parameterName is Type</code>, where
          parameterName must be the name of a parameter from the current
          function signature.
        </p>
        <p>
          pet is Fishはこの例での型述語になります。 述語はparameterName is
          Typeの形式をとり、
          parameterNameは現在の関数に指定されているパラメーターと同じ名前にしなければいけません。
        </p>
        <p>
          Any time isFish is called with some variable, TypeScript will narrow
          that variable to that specific type if the original type is
          compatible.
        </p>
        <p>
          isFishが値を指定されて呼び出されると、元の型と互換性があれば、
          TypeScriptはその変数を特定の型に狭めてくれます。
        </p>
        <pre><code>// Both calls to 'swim' and 'fly' are now okay.

    if (isFish(pet)) {
        pet.swim();
    }
    else {
        pet.fly();
    }</code></pre>

        <p>
          Notice that TypeScript not only knows that pet is a Fish in the if
          branch; it also knows that in the else branch, you don’t have a Fish,
          so you must have a Bird.
        </p>
        <p>
          TypeScriptは、そのif部分の中でpetがFishであることを知るだけで無く、
          else部分の中ではFishでは無いことから、Birdであることも知ることが出来ることに注意してください。
        </p>
      </section>
    </section>

    <section>
      <h2>typeof type guards</h2>
      <p>
        Let’s go back and write the code for the version of padLeft that uses
        union types. We could write it with type predicates as follows:
      </p>
      <p>
        padLeftに戻って、共用体型(union
        types)を使用したバージョンにコードを書き直してみましょう。
        次のように、型述語を使用して書いてみました。
      </p>
      <pre><code>function isNumber(x: any): x is number {
    return typeof x === "number";
}

function isString(x: any): x is string {
    return typeof x === "string";
}

function padLeft(value: string, padding: string | number) {
    if (isNumber(padding)) {
        return Array(padding + 1).join(" ") + value;
    }
    if (isString(padding)) {
        return padding + value;
    }
    throw new Error(`Expected string or number, got '${padding}'.`);
}</code></pre>

      <p>
        These typeof type guards are recognized in two different forms: typeof v
        === "typename" and typeof v !== "typename", where "typename" must be
        "number", "string", "boolean", or "symbol". While TypeScript won’t stop
        you from comparing to other strings, the language won’t recognize those
        expressions as type guards.
      </p>
      <p>
        これらのtypeofによる型の保護は、 typeof v === "typename"とtypeof v !==
        "typename"の異なる2つの形式を認識し、
        "typename"は"number"、"string"、"boolean"、"symbol"のいずれかでなければいけません。
        TypeScriptは他の文字列と比較することを止めるようなことはしませんが、
        型の保護としての認識は行ってくれません。
      </p>

      <section>
        <h2>instanceof type guards</h2>
        <p>
          If you’ve read about typeof type guards and are familiar with the
          instanceof operator in JavaScript, you probably have some idea of what
          this section is about.
        </p>
        <p>
          もし、typeofによる型の保護に目を通しており、JavaScriptのinstanceof演算子に慣れ親しんでいれば、
          このセクションの内容の予想がついているかもしれませんね。
        </p>

        <p>
          instanceof type guards are a way of narrowing types using their
          constructor function. For instance, let’s borrow our industrial
          string-padder example from earlier:
        </p>
        <p>
          instanceofによる型の保護はコンストラクタ関数を使用して、型を狭める方法です。
          例として、先程の産業用向けの文字列パディング(string-padder)を拝借して試してみましょう。
        </p>

        <pre><code>interface Padder {
    getPaddingString(): string
}

class SpaceRepeatingPadder implements Padder {
    constructor(private numSpaces: number) { }
    getPaddingString() {
        return Array(this.numSpaces + 1).join(" ");
    }
}

class StringPadder implements Padder {
    constructor(private value: string) { }
    getPaddingString() {
        return this.value;
    }
}

function getRandomPadder() {
    return Math.random() < 0.5 ?
        new SpaceRepeatingPadder(4) :
        new StringPadder("  ");
}

// Type is 'SpaceRepeatingPadder | StringPadder'
let padder: Padder = getRandomPadder();

if (padder instanceof SpaceRepeatingPadder) {
    padder; // type narrowed to 'SpaceRepeatingPadder'
}
if (padder instanceof StringPadder) {
    padder; // type narrowed to 'StringPadder'
}</code></pre>

        <p>
          The right side of the instanceof needs to be a constructor function,
          and TypeScript will narrow down to:
        </p>
        <p>
          instanceofの右側はコンストラクタ関数でなければならず、
          TypeScriptは下記の順で次のように処理します。
        </p>
        <ol>
          <li>
            the type of the function’s prototype property if its type is not any
          </li>
          <li>
            the union of types returned by that type’s construct signatures
          </li>
        </ol>
      </section>
    </section>

    <section>
      <h2>Nullable types</h2>
      <p>
        TypeScript has two special types, null and undefined, that have the
        values null and undefined respectively. We mentioned these briefly in
        the Basic Types section. By default, the type checker considers null and
        undefined assignable to anything. Effectively, null and undefined are
        valid values of every type. That means it’s not possible to stop them
        from being assigned to any type, even when you would like to prevent it.
        The inventor of null, Tony Hoare, calls this his “billion dollar
        mistake”.
      </p>
      <p>
        TypeScriptには特別な型nullとundefinedが存在し、それぞれnullとundefinedの値を持ちます。
        これらは、基本の型のセクションで概要を少しだけ説明しています。
        デフォルトでは、型チェッカーはnullとundefinedはどんなものにも割り当て可能であるとみなします。
        実際に、nullとundefinedはあらゆる型で有効な値です。
        つまり、例えそれを禁止にしたいとしても、どの型にも割り当てられないようにすることはできません。
        Tony Hoare氏は、これを10億ドルに相当する誤りと呼んでいます。
      </p>
      <p>
        The --strictNullChecks flag fixes this: when you declare a variable, it
        doesn’t automatically include null or undefined. You can include them
        explicitly using a union type:
      </p>
      <p>
        --strictNullChecksフラグはこれを正すもので、変数の宣言時に自動的にnullまたはundefinedを含めません。
        共用体型(union type)を使用して、明示的にそれを含めることが可能です。
      </p>
      <pre><code>let s = "foo";
s = null; // error, 'null' is not assignable to 'string'
let sn: string | null = "bar";
sn = null; // ok

sn = undefined; // error, 'undefined' is not assignable to 'string | null'</code></pre>
      <p>
        Note that TypeScript treats null and undefined differently in order to
        match JavaScript semantics. string | null is a different type than
        string | undefined and string | undefined | null.
      </p>

      <p>
        TypeScriptはJavaScriptのセマンティクスと一致させるために、nullとundefinedを別々に扱うことに注意してください。
        string | nullは、string | undefined、string | undefined |
        nullと異なる型になります。
      </p>

      <section>
        <h3>Optional parameters and properties</h3>

        <p>
          With --strictNullChecks, an optional parameter automatically adds |
          undefined:
        </p>
        <p>
          --strictNullChecksを使用すると、任意のパラメーターに自動的に|
          undefinedが追加されます。
        </p>
        <pre><code>function f(x: number, y?: number) {
    return x + (y || 0);
}
f(1, 2);
f(1);
f(1, undefined);
f(1, null); // error, 'null' is not assignable to 'number | undefined'</code></pre>

        <p>The same is true for optional properties:</p>

        <pre><code>class C {
    a: number;
    b?: number;
}
let c = new C();
c.a = 12;
c.a = undefined; // error, 'undefined' is not assignable to 'number'
c.b = 13;
c.b = undefined; // ok
c.b = null; // error, 'null' is not assignable to 'number | undefined'</code></pre>
      </section>
      <section>
        <h3>Type guards and type assertions</h3>
        <p>
          The same is true for optional properties:
        </p>
        <p>
          Nullの型(nullable
          types)は共用体(union)を使用して実装できるため、nullを取り除くには型の保護を使用する必要があります。
          幸いなことに、これはJavaScriptで書かれるコードと同じコードです。
        </p>
        <pre><code>class C {
    a: number;
    b?: number;
}
let c = new C();
c.a = 12;
c.a = undefined; // error, 'undefined' is not assignable to 'number'
c.b = 13;
c.b = undefined; // ok
c.b = null; // error, 'null' is not assignable to 'number | undefined'</code></pre>
      </section>

      <section>
        <h3>Type guards and type assertions</h3>
        <p>
          Since nullable types are implemented with a union, you need to use a
          type guard to get rid of the null. Fortunately, this is the same code
          you’d write in JavaScript:
        </p>
        <p>
          Nullの型(nullable
          types)は共用体(union)を使用して実装できるため、nullを取り除くには型の保護を使用する必要があります。
          幸いなことに、これはJavaScriptで書かれるコードと同じコードです。
        </p>
        <pre><code>function f(sn: string | null): string {
    if (sn == null) {
        return "default";
    }
    else {
        return sn;
    }
}</code></pre>
        <p>
          The null elimination is pretty obvious here, but you can use terser
          operators too:
        </p>
        <p>
          これでnullを明確に排除できていますが、次のように演算子を使用して返しても問題ありません。
        </p>
        <pre><code>function f(sn: string | null): string {
    return sn || "default";
}</code></pre>
        <p>
          In cases where the compiler can’t eliminate null or undefined, you can
          use the type assertion operator to manually remove them. The syntax is
          postfix !: identifier! removes null and undefined from the type of
          identifier:
        </p>
        <p>
          コンパイラがnullまたはundefinedを取り除くことができない場合は、
          型注釈(type assertion)の演算子を使用して手動で削除することができます。
          接頭辞の!は、型からnullとundefinedを取り除きます。
        </p>
        <pre><code>function broken(name: string | null): string {
  function postfix(epithet: string) {
    return name.charAt(0) + '.  the ' + epithet; // error, 'name' is possibly null
  }
  name = name || "Bob";
  return postfix("great");
}

function fixed(name: string | null): string {
  function postfix(epithet: string) {
    return name!.charAt(0) + '.  the ' + epithet; // ok
  }
  name = name || "Bob";
  return postfix("great");
}</code></pre>
        <p>
          The example uses a nested function here because the compiler can’t
          eliminate nulls inside a nested function (except immediately-invoked
          function expressions). That’s because it can’t track all calls to the
          nested function, especially if you return it from the outer function.
          Without knowing where the function is called, it can’t know what the
          type of name will be at the time the body executes. Type Aliases
        </p>
        <p>
          この例でネストされた関数を使用しているのは、コンパイラがネストされた関数内部でnullを取り除くことができないためです。
          (即時実行関数を除く)
          これは入れ子にされた関数の呼び出し全てを追跡できないためです。
          特に外部の関数から、それを戻り値として返す場合に追跡が非常に困難になります。
          関数が呼び出される場所が分からなければ、関数本体の実行時にどのような名前の型になるのかを知ることはできません。
        </p>
      </section>
    </section>

    <section>
      <h2>Type Aliases</h2>
      <p>
        Type aliases create a new name for a type. Type aliases are sometimes
        similar to interfaces, but can name primitives, unions, tuples, and any
        other types that you’d otherwise have to write by hand.
      </p>
      <p>
        型のエイリアスは、型に対する新しい名前を作成します。
        型のエイリアスはインターフェースと似ているところがありますが、
        プリミティブ、共用体(union)、タプル、その他にあなたの手によって書かれた型に対して名前を付けることが可能です。
      </p>
      <pre><code>type Name = string;
type NameResolver = () => string;
type NameOrResolver = Name | NameResolver;
function getName(n: NameOrResolver): Name {
    if (typeof n === "string") {
        return n;
    }
    else {
        return n();
    }
}</code></pre>
      <p>
        Aliasing doesn’t actually create a new type - it creates a new name to
        refer to that type. Aliasing a primitive is not terribly useful, though
        it can be used as a form of documentation.
      </p>
      <p>
        エイリアスは実際に新しい型を作成するわけではなく、その型を参照する新しい名前を作成するだけです。
        プリミティブへのエイリアスはそれほど有用ではありませんが、ドキュメントの形式上これを使って説明します。
      </p>
      <p>
        Just like interfaces, type aliases can also be generic - we can just add
        type parameters and use them on the right side of the alias declaration:
      </p>
      <p>
        インターフェースのように、エイリアスもジェネリクスになることも可能です。
        型パラメーターを追加し、エイリアス定義の右側でそれを使用します。
      </p>
      <pre><code>type Container&lt;T&gt; = { value: T };</code></pre>
      <p>
        We can also have a type alias refer to itself in a property:
      </p>
      <p>
        また、プロパティの中で自身を参照する型のエイリアスを持つことも可能です。
      </p>
      <pre><code>type Tree&lt;T&gt; = {
    value: T;
    left: Tree&lt;T&gt;;
    right: Tree&lt;T&gt;;
}</code></pre>
      <p>
        Together with intersection types, we can make some pretty mind-bending
        types:
      </p>
      <p>
        }
        交差型と組み合わせることで、非常に奇妙で理解し難い(mind-bending)型を作成することが出来ます。
      </p>
      <pre><code>type LinkedList&lt;T&gt; = T & { next: LinkedList&lt;T&gt; };

interface Person {
    name: string;
}

var people: LinkedList&lt;Person&gt;;
var s = people.name;
var s = people.next.name;
var s = people.next.next.name;
var s = people.next.next.next.name;</code></pre>

      <p>
        However, it’s not possible for a type alias to appear anywhere else on
        the right side of the declaration:
      </p>
      <p>
        ただし、型のエイリアスを定義の右側のいずれの場所にも表すことはできません。
      </p>
      <pre><code>type Yikes = Array&lt;Yikes&gt;; // error</code></pre>

      <section>
        <h3>Interfaces vs. Type Aliases</h3>
        <p>
          As we mentioned, type aliases can act sort of like interfaces;
          however, there are some subtle differences.
        </p>
        <p>
          既に述べたように、型のエイリアスはインターフェースのように振る舞うことができますが、
          幾つかの目立たない違いが存在します。
        </p>
        <p>
          One difference is that interfaces create a new name that is used
          everywhere. Type aliases don’t create a new name — for instance, error
          messages won’t use the alias name. In the code below, hovering over
          interfaced in an editor will show that it returns an Interface, but
          will show that aliased returns object literal type.
        </p>
        <p>
          1つ目の違いは、インターフェースはどこにでも使用できる新しい名前を作り出すことです。
          型のエイリアスはインスタンスのために新しい名前を作成せず、エラーメッセージにはそのエイリアス名は使用されません。
          下記のコードで、エディターでinterfaced上をホバーするとInterfaceが返されることが表示されますが、
          aliasedではオブジェクトのリテラル型が返されることが表示されます。
        </p>
        <pre><code>type Alias = { num: number }
interface Interface {
    num: number;
}
declare function aliased(arg: Alias): Alias;
declare function interfaced(arg: Interface): Interface;</code></pre>

        <p>
          A second more important difference is that type aliases cannot be
          extended or implemented from (nor can they extend/implement other
          types). Because an ideal property of software is being open to
          extension, you should always use an interface over a type alias if
          possible.
        </p>
        <p>
          2つ目のより重要な違いは、Type
          Aliasは拡張や実装が出来ないということです。
          (他の型からのextend/implement)
          ソフトウェアの理想的な特徴に拡張が許されていることが挙げられることから、
          あなたは可能な限り、型のエイリアスよりもインターフェースを使用するべきでしょう。
        </p>

        <p>
          On the other hand, if you can’t express some shape with an interface
          and you need to use a union or tuple type, type aliases are usually
          the way to go.
        </p>
        <p>
          一方で、もしインターフェースを形作る式を書くことができず、尚且つ共用体(union)、またはタプル型の使用が必要とされるケースであれば、
          型のエイリアスを使用するべきでしょう。
        </p>
      </section>
    </section>

    <section>
      <h2>String Literal Types</h2>
      <p>
        String literal types allow you to specify the exact value a string must
        have. In practice string literal types combine nicely with union types,
        type guards, and type aliases. You can use these features together to
        get enum-like behavior with strings.
      </p>
      <pre><code>type Easing = "ease-in" | "ease-out" | "ease-in-out";
class UIElement {
    animate(dx: number, dy: number, easing: Easing) {
        if (easing === "ease-in") {
            // ...
        }
        else if (easing === "ease-out") {
        }
        else if (easing === "ease-in-out") {
        }
        else {
            // error! should not pass null or undefined.
        }
    }
}

let button = new UIElement();
button.animate(0, 0, "ease-in");
button.animate(0, 0, "uneasy"); // error: "uneasy" is not allowed here</code></pre>
      <p>
        You can pass any of the three allowed strings, but any other string will
        give the error
      </p>
      <pre><code>Argument of type '"uneasy"' is not assignable to parameter of type '"ease-in" | "ease-out" | "ease-in-out"'</code></pre>

      <p>
        String literal types can be used in the same way to distinguish
        overloads:
      </p>
      <pre><code>function createElement(tagName: "img"): HTMLImageElement;
        function createElement(tagName: "input"): HTMLInputElement;
        // ... more overloads ...
        function createElement(tagName: string): Element {
            // ... code goes here ...
        }
        </code></pre>
    </section>

    <section>
      <h2>Numeric Literal Types</h2>
      <p>
        TypeScript also has numeric literal types.
      </p>
      <pre><code>function rollDice(): 1 | 2 | 3 | 4 | 5 | 6 {
    // ...
}</code></pre>
      <p>
        These are seldom written explicitly, they can be useful when narrowing
        can catch bugs:
      </p>
      <p>
        これらが明示的に書かれることはめったにありませんが、絞り込むことがバグを捕らえることができるときそれらは役に立ちます：
      </p>
      <pre><code>function foo(x: number) {
    if (x !== 1 || x !== 2) {
        //         ~~~~~~~
        // Operator '!==' cannot be applied to types '1' and '2'.
    }
}</code></pre>
      <p></p>
    </section>

    <section>
      <h2>Enum Member Types</h2>
      <p>
        As mentioned in our section on enums, enum members have types when every
        member is literal-initialized.
      </p>
      <p>
        Much of the time when we talk about “singleton types”, we’re referring
        to both enum member types as well as numeric/string literal types,
        though many users will use “singleton types” and “literal types”
        interchangeably.
      </p>
    </section>

    <section>
      <h2>Discriminated Unions</h2>
      <p>
        You can combine singleton types, union types, type guards, and type
        aliases to build an advanced pattern called discriminated unions, also
        known as tagged unions or algebraic data types. Discriminated unions are
        useful in functional programming. Some languages automatically
        discriminate unions for you; TypeScript instead builds on JavaScript
        patterns as they exist today. There are three ingredients:
      </p>
      <ol>
        <li>
          Types that have a common, singleton type property — the discriminant.
        </li>
        <li>
          A type alias that takes the union of those types — the union.
        </li>
        <li>
          Type guards on the common property.
        </li>
      </ol>
      <pre><code>interface Square {
    kind: "square";
    size: number;
}
interface Rectangle {
    kind: "rectangle";
    width: number;
    height: number;
}
interface Circle {
    kind: "circle";
    radius: number;
}</code></pre>
      <p>
        First we declare the interfaces we will union. Each interface has a kind
        property with a different string literal type. The kind property is
        called the discriminant or tag. The other properties are specific to
        each interface. Notice that the interfaces are currently unrelated.
        Let’s put them into a union:
      </p>
      <p>
        まず、共用体(union)にするインターフェースを宣言します。
        各インターフェースは、異なる文字列リテラル型のkindプロパティを持ちます。
        kindプロパティは「判別(discriminant)」または「タグ(tag)」と呼ばれます。
        他のプロパティは、各インターフェース特有のものです。
        このインターフェースには、目下のところ関連性が無いことに注意してください。
        これらを共用体(union)として配置してみましょう。
      </p>

      <pre><code>type Shape = Square | Rectangle | Circle;</code></pre>

      <p>
        Now let’s use the discriminated union:
      </p>
      <pre><code>function area(s: Shape) {
    switch (s.kind) {
        case "square": return s.size * s.size;
        case "rectangle": return s.height * s.width;
        case "circle": return Math.PI * s.radius ** 2;
    }
}</code></pre>

      <section>
        <h3>Exhaustiveness checking</h3>
        <p>
          We would like the compiler to tell us when we don’t cover all variants
          of the discriminated union. For example, if we add Triangle to Shape,
          we need to update area as well:
        </p>

        <pre><code>type Shape = Square | Rectangle | Circle | Triangle;
function area(s: Shape) {
    switch (s.kind) {
        case "square": return s.size * s.size;
        case "rectangle": return s.height * s.width;
        case "circle": return Math.PI * s.radius ** 2;
    }
    // should error here - we didn't handle case "triangle"
}</code></pre>
        <p>
          There are two ways to do this. The first is to turn on
          --strictNullChecks and specify a return type:
        </p>
        <pre><code>function area(s: Shape): number { // error: returns number | undefined
  switch (s.kind) {
      case "square": return s.size * s.size;
      case "rectangle": return s.height * s.width;
      case "circle": return Math.PI * s.radius ** 2;
  }
}</code></pre>
        <p>
          Because the switch is no longer exhaustive, TypeScript is aware that
          the function could sometimes return undefined. If you have an explicit
          return type number, then you will get an error that the return type is
          actually number | undefined. However, this method is quite subtle and,
          besides, --strictNullChecks does not always work with old code.
        </p>
        <p>
          The second method uses the never type that the compiler uses to check
          for exhaustiveness:
        </p>
        <pre><code>function assertNever(x: never): never {
    throw new Error("Unexpected object: " + x);
}
function area(s: Shape) {
    switch (s.kind) {
        case "square": return s.size * s.size;
        case "rectangle": return s.height * s.width;
        case "circle": return Math.PI * s.radius ** 2;
        default: return assertNever(s); // error here if there are missing cases
    }
}</code></pre>
        <p>
          ere, assertNever checks that s is of type never — the type that’s left
          after all other cases have been removed. If you forget a case, then s
          will have a real type and you will get a type error. This method
          requires you to define an extra function, but it’s much more obvious
          when you forget it.
        </p>
      </section>
    </section>

    <section>
      <h2>Polymorphic this types</h2>
      <p>
        A polymorphic this type represents a type that is the subtype of the
        containing class or interface. This is called F-bounded polymorphism.
        This makes hierarchical fluent interfaces much easier to express, for
        example. Take a simple calculator that returns this after each
        operation:
      </p>
      <pre><code>class BasicCalculator {
public constructor(protected value: number = 0) { }
public currentValue(): number {
    return this.value;
}
public add(operand: number): this {
    this.value += operand;
    return this;
}
public multiply(operand: number): this {
    this.value *= operand;
    return this;
}
// ... other operations go here ...
}

let v = new BasicCalculator(2)
        .multiply(5)
        .add(1)
        .currentValue();</code></pre>
      <p>
        Since the class uses this types, you can extend it and the new class can
        use the old methods with no changes.
      </p>

      <pre><code>class ScientificCalculator extends BasicCalculator {
    public constructor(value = 0) {
        super(value);
    }
    public sin() {
        this.value = Math.sin(this.value);
        return this;
    }
    // ... other operations go here ...
}

let v = new ScientificCalculator(2)
        .multiply(5)
        .sin()
        .add(1)
        .currentValue();</code></pre>
      <p>
        Without this types, ScientificCalculator would not have been able to
        extend BasicCalculator and keep the fluent interface. multiply would
        have returned BasicCalculator, which doesn’t have the sin method.
        However, with this types, multiply returns this, which is
        ScientificCalculator here.
      </p>
    </section>

    <section>
      <h2>Index types</h2>
      <p>
        With index types, you can get the compiler to check code that uses
        dynamic property names. For example, a common Javascript pattern is to
        pick a subset of properties from an object:
      </p>
      <pre><code>
          function pluck(o, names) {
            return names.map(n => o[n]);
        }
      </code></pre>
      <p>
        Here’s how you would write and use this function in TypeScript, using
        the index type query and indexed access operators:
      </p>
      <pre><code>function pluck&lt;T, K extends keyof T&gt;(o: T, names: K[]): T[K][] {
    return names.map(n => o[n]);
  }
  
  interface Person {
      name: string;
      age: number;
  }
  let person: Person = {
      name: 'Jarid',
      age: 35
  };
  let strings: string[] = pluck(person, ['name']); // ok, string[]</code></pre>

      <p>
        The compiler checks that name is actually a property on Person. The
        example introduces a couple of new type operators. First is keyof T, the
        index type query operator. For any type T, keyof T is the union of
        known, public property names of T. For example:
      </p>

      <pre><code>let personProps: keyof Person; // 'name' | 'age'</code></pre>
      <p>
        keyof Person is completely interchangeable with 'name' | 'age'. The
        difference is that if you add another property to Person, say address:
        string, then keyof Person will automatically update to be 'name' | 'age'
        | 'address'. And you can use keyof in generic contexts like pluck, where
        you can’t possibly know the property names ahead of time. That means the
        compiler will check that you pass the right set of property names to
        pluck:
      </p>
      <pre><code>pluck(person, ['age', 'unknown']); // error, 'unknown' is not in 'name' | 'age'</code></pre>

      <p>
        The second operator is T[K], the indexed access operator. Here, the type
        syntax reflects the expression syntax. That means that person['name']
        has the type Person['name'] — which in our example is just string.
        However, just like index type queries, you can use T[K] in a generic
        context, which is where its real power comes to life. You just have to
        make sure that the type variable K extends keyof T. Here’s another
        example with a function named getProperty.
      </p>
      <pre><code>
          function getProperty&lt;T, K extends keyof T&gt;(o: T, name: K): T[K] {
              return o[name]; // o[name] is of type T[K]
          }
      </code></pre>
      <p>
        In getProperty, o: T and name: K, so that means o[name]: T[K]. Once you
        return the T[K] result, the compiler will instantiate the actual type of
        the key, so the return type of getProperty will vary according to which
        property you request.
      </p>
      <pre><code>let name: string = getProperty(person, 'name');
let age: number = getProperty(person, 'age');
let unknown = getProperty(person, 'unknown'); // error, 'unknown' is not in 'name' | 'age'
</code></pre>

      <section>
        <h3>Index types and string index signatures</h3>
        <p>
          keyof and T[K] interact with string index signatures. If you have a
          type with a string index signature, keyof T will just be string. And
          T[string] is just the type of the index signature:
        </p>
      </section>
      <p></p>
    </section>

    <section>
      <h2>Mapped types</h2>
      <p>
        A common task is to take an existing type and make each of its
        properties optional:
      </p>

      <pre><code>interface PersonPartial {
    name?: string;
    age?: number;
}</code></pre>
      <p>
        Or we might want a readonly version:
      </p>
      <pre><code>interface PersonReadonly {
    readonly name: string;
    readonly age: number;
}</code></pre>

      <p>
        This happens often enough in Javascript that TypeScript provides a way
        to create new types based on old types — mapped types. In a mapped type,
        the new type transforms each property in the old type in the same way.
        For example, you can make all properties of a type readonly or optional.
        Here are a couple of examples:
      </p>
      <pre><code>type Readonly<T> = {
    readonly [P in keyof T]: T[P];
}
type Partial<T> = {
    [P in keyof T]?: T[P];
}
      </code></pre>
      <p>
          And to use it:
      </p>
<pre><code>type PersonPartial = Partial<Person>;
  type ReadonlyPerson = Readonly<Person>;</code></pre>
  
    <p>
        Note that this syntax describes a type rather than a member. If you want to add additional members, you can use an intersection type:
    </p>
  <pre><code>// Use this:
type PartialWithNewMember<T> = {
  [P in keyof T]?: T[P];
} & { newMember: boolean }

// **Do not** use the following!
// This is an error!
type PartialWithNewMember<T> = {
  [P in keyof T]?: T[P];
  newMember: boolean;
}</code></pre>
<p>
    Let’s take a look at the simplest mapped type and its parts:
</p>
<pre><code>type Keys = 'option1' | 'option2';
    type Flags = { [K in Keys]: boolean };</code></pre>
  
  <p>
      The syntax resembles the syntax for index signatures with a for .. in inside. There are three parts:


  </p>
  <ol>
    <li>

      The type variable K, which gets bound to each property in turn.
    </li>
    <li>
      The string literal union Keys, which contains the names of properties to iterate over.

    </li>
    <li>
        The resulting type of the property.
    </li>
  </ol>
  <p>
      In this simple example, Keys is a hard-coded list of property names and the property type is always boolean, so this mapped type is equivalent to writing:
  </p>

  <pre><code>type Flags = {
    option1: boolean;
    option2: boolean;
}</code></pre>

<p>
    Real applications, however, look like Readonly or Partial above. They’re based on some existing type, and they transform the properties in some way. That’s where keyof and indexed access types come in:
</p>
<pre><code>type NullablePerson = { [P in keyof Person]: Person[P] | null }
type PartialPerson = { [P in keyof Person]?: Person[P] }</code></pre>
  
<p>
    But it’s more useful to have a general version.
</p>

<pre><code>type Nullable<T> = { [P in keyof T]: T[P] | null }
type Partial<T> = { [P in keyof T]?: T[P] }</code></pre>

<p>
    In these examples, the properties list is keyof T and the resulting type is some variant of T[P]. This is a good template for any general use of mapped types. That’s because this kind of transformation is homomorphic, which means that the mapping applies only to properties of T and no others. The compiler knows that it can copy all the existing property modifiers before adding any new ones. For example, if Person.name was readonly, Partial<Person>.name would be readonly and optional.
</p>

<p>
    Here’s one more example, in which T[P] is wrapped in a Proxy<T> class:
</p>

<pre><code>type Proxy<T> = {
    get(): T;
    set(value: T): void;
}
type Proxify<T> = {
    [P in keyof T]: Proxy<T[P]>;
}
function proxify<T>(o: T): Proxify<T> {
   // ... wrap proxies ...
}
let proxyProps = proxify(props);</code></pre>

<p>
    Note that Readonly<T> and Partial<T> are so useful, they are included in TypeScript’s standard library along with Pick and Record:
</p>

<pre><code>type Pick&lt;T, K extends keyof T&gt; = {
    [P in K]: T[P];
}
type Record&lt;K extends keyof any, T&gt; = {
    [P in K]: T;
}</code></pre>

<p>
    Readonly, Partial and Pick are homomorphic whereas Record is not. One clue that Record is not homomorphic is that it doesn’t take an input type to copy properties from:
</p>

<pre><code>type ThreeStringProps = Record<'prop1' | 'prop2' | 'prop3', string></code></pre>

<p>
    Non-homomorphic types are essentially creating new properties, so they can’t copy property modifiers from anywhere.
</p>

<section>
  <h3>Inference from mapped types</h3>
<p>
    Now that you know how to wrap the properties of a type, the next thing you’ll want to do is unwrap them. Fortunately, that’s pretty easy:
</p>

<pre><code>function unproxify<T>(t: Proxify<T>): T {
    let result = {} as T;
    for (const k in t) {
        result[k] = t[k].get();
    }
    return result;
}

let originalProps = unproxify(proxyProps);
</code></pre>

<p>
    Note that this unwrapping inference only works on homomorphic mapped types. If the mapped type is not homomorphic you’ll have to give an explicit type parameter to your unwrapping function.
</p>
</section>

  </section>

    <section>
      <h2>Conditional Types        </h2>
      <p>TypeScript 2.8 introduces conditional types which add the ability to express non-uniform type mappings. A conditional type selects one of two possible types based on a condition expressed as a type relationship test:</p>
    <pre><code>T extends U ? X : Y</code></pre>
    
<p>
    The type above means when T is assignable to U the type is X, otherwise the type is Y.
</p>
<p>
    A conditional type T extends U ? X : Y is either resolved to X or Y, or deferred because the condition depends on one or more type variables. When T or U contains type variables, whether to resolve to X or Y, or to defer, is determined by whether or not the type system has enough information to conclude that T is always assignable to U.
</p>

<p>
    As an example of some types that are immediately resolved, we can take a look at the following example:
</p>

<pre><code>declare function f<T extends boolean>(x: T): T extends true ? string : number;

// Type is 'string | number
let x = f(Math.random() &lt; 0.5)</code></pre>

<p>
    Another example would be the TypeName type alias, which uses nested conditional types:
</p>

<pre><code>type TypeName<T> =
    T extends string ? "string" :
    T extends number ? "number" :
    T extends boolean ? "boolean" :
    T extends undefined ? "undefined" :
    T extends Function ? "function" :
    "object";

type T0 = TypeName<string>;  // "string"
type T1 = TypeName<"a">;  // "string"
type T2 = TypeName<true>;  // "boolean"
type T3 = TypeName<() => void>;  // "function"
type T4 = TypeName<string[]>;  // "object"</code></pre>

<p>
    But as an example of a place where conditional types are deferred - where they stick around instead of picking a branch - would be in the following:
</p>

<pre><code>interface Foo {
    propA: boolean;
    propB: boolean;
}

declare function f<T>(x: T): T extends Foo ? string : number;

function foo<U>(x: U) {
    // Has type 'U extends Foo ? string : number'
    let a = f(x);

    // This assignment is allowed though!
    let b: string | number = a;
}</code></pre>

<p>
    In the above, the variable a has a conditional type that hasn’t yet chosen a branch. When another piece of code ends up calling foo, it will substitute in U with some other type, and TypeScript will re-evaluate the conditional type, deciding whether it can actually pick a branch.
</p>

<p>
    In the meantime, we can assign a conditional type to any other target type as long as each branch of the conditional is assignable to that target. So in our example above we were able to assign U extends Foo ? string : number to string | number since no matter what the conditional evaluates to, it’s known to be either string or number.

</p>
<section>
  <h3>Distributive conditional types</h3>

  <p>
      Conditional types in which the checked type is a naked type parameter are called distributive conditional types. Distributive conditional types are automatically distributed over union types during instantiation. For example, an instantiation of T extends U ? X : Y with the type argument A | B | C for T is resolved as (A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y).
  </p>

  <pre><code>type T10 = TypeName<string | (() => void)>;  // "string" | "function"
type T12 = TypeName<string | string[] | undefined>;  // "string" | "object" | "undefined"
type T11 = TypeName<string[] | number[]>;  // "object"</code></pre>

<p>
    In instantiations of a distributive conditional type T extends U ? X : Y, references to T within the conditional type are resolved to individual constituents of the union type (i.e. T refers to the individual constituents after the conditional type is distributed over the union type). Furthermore, references to T within X have an additional type parameter constraint U (i.e. T is considered assignable to U within X).

</p>

<pre><code>
    type BoxedValue<T> = { value: T };
    type BoxedArray<T> = { array: T[] };
    type Boxed<T> = T extends any[] ? BoxedArray<T[number]> : BoxedValue<T>;
    
    type T20 = Boxed<string>;  // BoxedValue<string>;
    type T21 = Boxed<number[]>;  // BoxedArray<number>;
    type T22 = Boxed<string | number[]>;  // BoxedValue<string> | BoxedArray<number>;</code></pre>

<p>
    Notice that T has the additional constraint any[] within the true branch of Boxed<T> and it is therefore possible to refer to the element type of the array as T[number]. Also, notice how the conditional type is distributed over the union type in the last example.
</p>

<p>
    The distributive property of conditional types can conveniently be used to filter union types:
</p>
<pre><code>type Diff<T, U> = T extends U ? never : T;  // Remove types from T that are assignable to U
    type Filter<T, U> = T extends U ? T : never;  // Remove types from T that are not assignable to U
    
    type T30 = Diff<"a" | "b" | "c" | "d", "a" | "c" | "f">;  // "b" | "d"
    type T31 = Filter<"a" | "b" | "c" | "d", "a" | "c" | "f">;  // "a" | "c"
    type T32 = Diff<string | number | (() => void), Function>;  // string | number
    type T33 = Filter<string | number | (() => void), Function>;  // () => void
    
    type NonNullable<T> = Diff<T, null | undefined>;  // Remove null and undefined from T
    
    type T34 = NonNullable<string | number | undefined>;  // string | number
    type T35 = NonNullable<string | string[] | null | undefined>;  // string | string[]
    
    function f1<T>(x: T, y: NonNullable<T>) {
        x = y;  // Ok
        y = x;  // Error
    }
    
    function f2<T extends string | undefined>(x: T, y: NonNullable<T>) {
        x = y;  // Ok
        y = x;  // Error
        let s1: string = x;  // Error
        let s2: string = y;  // Ok
    }</code></pre>

<p>Conditional types are particularly useful when combined with mapped types:</p>

<pre><code>type FunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T];
    type FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;
    
    type NonFunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? never : K }[keyof T];
    type NonFunctionProperties<T> = Pick<T, NonFunctionPropertyNames<T>>;
    
    interface Part {
        id: number;
        name: string;
        subparts: Part[];
        updatePart(newName: string): void;
    }
    
    type T40 = FunctionPropertyNames<Part>;  // "updatePart"
    type T41 = NonFunctionPropertyNames<Part>;  // "id" | "name" | "subparts"
    type T42 = FunctionProperties<Part>;  // { updatePart(newName: string): void }
    type T43 = NonFunctionProperties<Part>;  // { id: number, name: string, subparts: Part[] }</code></pre>

<p>
    Similar to union and intersection types, conditional types are not permitted to reference themselves recursively. For example the following is an error.
</p>

<pre><code>type ElementType<T> = T extends any[] ? ElementType<T[number]> : T;  // Error</code></pre>

</section>

<section>
  <h3>Type inference in conditional types</h3>
  <p>
      Within the extends clause of a conditional type, it is now possible to have infer declarations that introduce a type variable to be inferred. Such inferred type variables may be referenced in the true branch of the conditional type. It is possible to have multiple infer locations for the same type variable.
  </p>
  <p>
      For example, the following extracts the return type of a function type:
  </p>
  <pre><code>type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;</code></pre>

    <p>
        Conditional types can be nested to form a sequence of pattern matches that are evaluated in order:
    </p>

    <pre><code>type Unpacked<T> =
        T extends (infer U)[] ? U :
        T extends (...args: any[]) => infer U ? U :
        T extends Promise<infer U> ? U :
        T;
    
    type T0 = Unpacked<string>;  // string
    type T1 = Unpacked<string[]>;  // string
    type T2 = Unpacked<() => string>;  // string
    type T3 = Unpacked<Promise<string>>;  // string
    type T4 = Unpacked<Promise<string>[]>;  // Promise<string>
    type T5 = Unpacked<Unpacked<Promise<string>[]>>;  // string
    </code></pre>

    <p>
        The following example demonstrates how multiple candidates for the same type variable in co-variant positions causes a union type to be inferred:
    </p>

    <pre><code>type Foo<T> = T extends { a: infer U, b: infer U } ? U : never;
        type T10 = Foo<{ a: string, b: string }>;  // string
        type T11 = Foo<{ a: string, b: number }>;  // string | number</code></pre>

        <p>
            Likewise, multiple candidates for the same type variable in contra-variant positions causes an intersection type to be inferred:
        </p>

        <pre><code>type Bar<T> = T extends { a: (x: infer U) => void, b: (x: infer U) => void } ? U : never;
            type T20 = Bar<{ a: (x: string) => void, b: (x: string) => void }>;  // string
            type T21 = Bar<{ a: (x: string) => void, b: (x: number) => void }>;  // string & number</code></pre>

<p>
    When inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the last signature (which, presumably, is the most permissive catch-all case). It is not possible to perform overload resolution based on a list of argument types.
</p>
<pre><code>declare function foo(x: string): number;
    declare function foo(x: number): string;
    declare function foo(x: string | number): string | number;
    type T30 = ReturnType<typeof foo>;  // string | number</code></pre>

<p>
    It is not possible to use infer declarations in constraint clauses for regular type parameters:
</p>

<pre><code>type ReturnType<T extends (...args: any[]) => infer R> = R;  // Error, not supported</code></pre>

<p>
    However, much the same effect can be obtained by erasing the type variables in the constraint and instead specifying a conditional type:
</p>

<pre><code>type AnyFunction = (...args: any[]) => any;
    type ReturnType<T extends AnyFunction> = T extends (...args: any[]) => infer R ? R : any;</code></pre>

  </section>

  <section>
    <h3>Predefined conditional types</h3>
    <p>
        TypeScript 2.8 adds several predefined conditional types to lib.d.ts:
    </p>
    <ul>
      <li>
        Exclude<T, U> – Exclude from T those types that are assignable to U.

      </li>
      <li>
        Extract<T, U> – Extract from T those types that are assignable to U.

      </li>
      <li>
        NonNullable<T> – Exclude null and undefined from T.

      </li>
      <li>

        ReturnType<T> – Obtain the return type of a function type.
      </li>
      <li>
              InstanceType<T> – Obtain the instance type of a constructor function type.
      </li>
    </ul>
    <pre><code>type T00 = Exclude<"a" | "b" | "c" | "d", "a" | "c" | "f">;  // "b" | "d"
      type T01 = Extract<"a" | "b" | "c" | "d", "a" | "c" | "f">;  // "a" | "c"
      
      type T02 = Exclude<string | number | (() => void), Function>;  // string | number
      type T03 = Extract<string | number | (() => void), Function>;  // () => void
      
      type T04 = NonNullable<string | number | undefined>;  // string | number
      type T05 = NonNullable<(() => string) | string[] | null | undefined>;  // (() => string) | string[]
      
      function f1(s: string) {
          return { a: 1, b: s };
      }
      
      class C {
          x = 0;
          y = 0;
      }
      
      type T10 = ReturnType<() => string>;  // string
      type T11 = ReturnType<(s: string) => void>;  // void
      type T12 = ReturnType<(<T>() => T)>;  // {}
      type T13 = ReturnType<(<T extends U, U extends number[]>() => T)>;  // number[]
      type T14 = ReturnType<typeof f1>;  // { a: number, b: string }
      type T15 = ReturnType<any>;  // any
      type T16 = ReturnType<never>;  // never
      type T17 = ReturnType<string>;  // Error
      type T18 = ReturnType<Function>;  // Error
      
      type T20 = InstanceType<typeof C>;  // C
      type T21 = InstanceType<any>;  // any
      type T22 = InstanceType<never>;  // never
      type T23 = InstanceType<string>;  // Error
      type T24 = InstanceType<Function>;  // Error</code></pre>

<blockquote>
    Note: The Exclude type is a proper implementation of the Diff type suggested here. We’ve used the name Exclude to avoid breaking existing code that defines a Diff, plus we feel that name better conveys the semantics of the type. We did not include the Omit<T, K> type because it is trivially written as Pick<T, Exclude<keyof T, K>>.
</blockquote>

      </section>

    </section>

    <section>
        <h2></h2>
        <p></p>
      </section>
  </body>
</html>
